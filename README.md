# Homeworks-10m-2023

Называйте, пожалуйста, файлы домашнего задания в соответствии с заданиями, которые в них выполнены, либо прикрепляйте текстовый файл с описанием.

## Потокобезопасная очередь

В данной задаче требуется реализовать класс `Queue`, который бы соответствовал очереди для хранения целых чисел. То есть добавляются элементы только в конец, удаляются только из начала. Реализация должна подходить для безопасного использования в нескольких потоках.
Иначе говорят, мы хотим гарантировать, что модификация одних и тех же данных будет проходить одновременно только в одном потоке. 

1. Для начала добавим в очередь стандартные методы. Для хранения самих элементов можно использовать что угодно, хоть стандартную очередь `std::queue<int>`
   * `void put(int value)` -- добавляет значение `value` в очередь
   * `int pop()` -- удаляет первый элемент в очереди и возвращает его значение. Считаем, что при попытке удалить из пустой очереди программа упадет, как и должна
   * `size_t size()` -- возвращает текущее количество элементов в очереди. Можно использовать для результата любой другой целочисленный тип, подходящий для неотрицательных значений.
2. Теперь добавим в очередь метод 
    * `int wait_and_pop()` -- если очередь пуста, то ждет, пока в ней появится хотя бы один элемент, иначе удаляет первый элемент из очереди и возвращает его значение.
3. Далее усложним способ хранения. Заменим его на **связный список**, узлы которого выделены на куче.
4. И дополнительным пунктом оптимизируем использование блокировок в случае связного списка. Заметим, что при добавлении в начало и удалении из конца в большей части случаев редактируются разные области памяти, так что это можно делать параллельно. Реализуйте это с помощью использования более чем одной блокировки для всей структуры.


### Заметки с пары. Связный список
Для хранения одного элемента нам понадобится структура вершины. 
`` 
    struct Node {
        int value;
        Node* next;
    };
``
То есть в вершине хранится значение и указатель на следующую вершину. Очень похоже на дерево-бамбук. Конечно, тип значения может быть любым, но для примера мы возьмем `int`.
Итак мы получаем последовательность вершин, у каждой из которых есть следующая. Если ее нет, то в поле `next` можно записать `nullptr`, он же `0`, такая вершина в связном списке может быть только одна. 

Тогда для хранения набора чисел таким образом нужен только указатель на первый элемент, назовем его `head`. Теперь для добавления элемента в конец нужно найти последний элемент.

``
    Node* last = head;
    while (last->next) {
        last = last->next;
    }
``

После нахождения последнего, можно добавить новых элемент по значению. Пусть поступил запрос на добавление числа `x`

``
    Node* n = new Node(x);
    last->next = n;
``

Удобным может быть хранение последней вершины вместе с первой, назовем ее `tail`. Тогда добавление в конец будет выглядеть короче

``
    Node* n = new Node(x);
    tail->next = n;
    tail = n;
``

Теперь для удаления первого нам нужно сохранить в `head` следующий элемент, а старый удалить и очистить память.

`` 
    Node* prev_head = head;
    head = head->next;
    delete prev_head;
``

Можем добавить возвращение результат в виде значения вершины в удаление.


`` 
    Node* prev_head = head;
    head = head->next;
    int value = prev_head->value;
    delete prev_head;
    return value;
``



Конечно, при добавлении и удалении нужно рассмотреть крайние случаи пустой очереди или очереди из одного элемента.

